# Generated by nuclio.export.NuclioExporter

import warnings

warnings.simplefilter(action="ignore", category=FutureWarning)

import numpy as np
import pandas as pd

from mlrun.execution import MLClientCtx
from mlrun.datastore import DataItem
from mlrun.artifacts import TableArtifact, PlotlyArtifact
import plotly.figure_factory as ff
import plotly.express as px
import plotly.graph_objects as go

from typing import List

pd.set_option("display.float_format", lambda x: "%.2f" % x)


def summarize(
        context: MLClientCtx,
        table: DataItem,
        label_column: str = None,
        class_labels: List[str] = [],
        plot_hist: bool = True,
        plots_dest: str = "plots",
        update_dataset=False,
        frac: float = 0.10
) -> None:
    """Summarize a table

    :param context:         the function context
    :param table:           MLRun input pointing to pandas dataframe (csv/parquet file path)
    :param label_column:    ground truth column label
    :param class_labels:    label for each class in tables and plots
    :param plot_hist:       (True) set this to False for large tables
    :param plots_dest:      destination folder of summary plots (relative to artifact_path)
    :param update_dataset:  when the table is a registered dataset update the charts in-place
    :param frac:  when the table has more than 5000 samples, the function will execute on random frac from the data
    """

    df = table.as_df()
    if df.shape[0] > 5000:
        df = df.sample(frac=frac)
    extra_data = {}

    # histograms
    try:
        df[label_column] = df[label_column].apply(str)
        fig = ff.create_scatterplotmatrix(df, diag='histogram', index=label_column, width=2500, height=2500)
        fig.update_layout(title_text='<i><b>Histograms matrix</b></i>')
        extra_data["histograms"] = context.log_artifact(
            PlotlyArtifact(key="histograms", figure=fig),
            local_path=f"{plots_dest}/hist.html",
            db_key=False,
        )
    except Exception as e:
        context.logger.error(f"Failed to create pairplot histograms due to: {e}")
    df[label_column] = df[label_column].astype(np.float64)

    # violin
    try:
        fig = go.Figure()
        for (columnName, columnData) in df.iteritems():
            fig.add_trace(go.Violin(x=[columnName]*columnData.shape[0],
                                    y=columnData,
                                    name=columnName,
                                    box_visible=True,
                                    meanline_visible=True))

        fig.update_layout(title_text='<i><b>Violin Plot</b></i>')
        extra_data["violin"] = context.log_artifact(
            PlotlyArtifact(key="violin", figure=fig),
            local_path=f"{plots_dest}/violin.html",
            db_key=False,
        )
    except Exception as e:
        context.logger.warn(f"Failed to create violin distribution plots due to: {e}")

    # imbalance
    if label_column:
        labels_count = df[label_column].value_counts().sort_index()
        df_labels_count = pd.DataFrame(labels_count)
        df_labels_count.rename(columns={label_column: "Total"}, inplace=True)
        df_labels_count[label_column] = labels_count.index
        try:
            fig = px.pie(df_labels_count, names=label_column, values="Total")
            fig.update_layout(title_text='<i><b>Labels balance</b></i>')
            extra_data["imbalance"] = context.log_artifact(
                PlotlyArtifact(key="imbalance", figure=fig),
                local_path=f"{plots_dest}/imbalance.html",
            )
        except Exception as e:
            context.logger.warn(f"Failed to create class imbalance plot due to: {e}")
        context.log_artifact(
            TableArtifact(
                "imbalance-weights-vec", df=pd.DataFrame({"weights": labels_count})
            ),
            local_path=f"{plots_dest}/imbalance-weights-vec.csv",
            db_key=False,
        )

    # correlation - matrix
    df.drop([label_column], axis=1, inplace=True)
    tblcorr = df.corr()
    context.log_artifact(
        TableArtifact("correlation-matrix", df=tblcorr, visible=True),
        local_path=f"{plots_dest}/correlation-matrix.csv",
        db_key=False,
    )

    try:
        z = tblcorr.values.tolist()
        z_text = [["{:.2f}".format(y) for y in x] for x in z]
        fig = ff.create_annotated_heatmap(z, x=list(df.columns),
                                          y=list(df.columns),
                                          annotation_text=z_text, colorscale='agsunset')
        fig['layout']['yaxis']['autorange'] = "reversed"  # l -> r
        fig.update_layout(title_text='<i><b>Correlation matrix</b></i>')
        fig['data'][0]['showscale'] = True

        extra_data["correlation"] = context.log_artifact(
            PlotlyArtifact(key="correlation", figure=fig),
            local_path=f"{plots_dest}/corr.html",
            db_key=False,
        )
    except Exception as e:
        context.logger.warn(f"Failed to create features correlation plot due to: {e}")
    if update_dataset and table.meta and table.meta.kind == "dataset":
        from mlrun.artifacts import update_dataset_meta

        update_dataset_meta(table.meta, extra_data=extra_data)

    # TODO : Plots according to client wishes - like preform histogram on selected features.
    # TODO : 3-D plot on on selected features.
    # TODO : Reintegration plot on on selected features.


